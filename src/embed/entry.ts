import React from 'react';
import ReactDOM from 'react-dom';
import { Story, Size, Variant, Alignment } from './types';
import { StoryStyle, StoryCarousel, StoryViewer } from './components/EmbedStoryStyle';
import './styles.css';

console.log('üé¨ D√©marrage du script HehoStory');
console.log('üîÑ Version du build:', new Date().toISOString());
console.log('üîç DEBUG MODE ACTIV√â - v2');
console.log('üéØ Test de mise √† jour - Build du', new Date().toLocaleString());

// Types pour la base de donn√©es
interface DBStory {
  id: string;
  content: string;
  thumbnail: string;
  profile_image?: string;
  profile_name?: string;
}

interface DBWidget {
  id: string;
  format: string;
  story_ids: string[];
  settings: string;
  border_color?: string;
}

interface WidgetFormat {
  type: Variant;
  size: Size;
  alignment: Alignment;
}

interface Widget {
  id: string;
  format: WidgetFormat;
  story_ids: string[];
  settings: {
    autoplay?: boolean;
    loop?: boolean;
  };
}

// Point d'entr√©e du script d'embed HehoStory
(() => {
  console.log('üèÅ Initialisation HehoStory');
  
  // Configuration de l'API
  const API_BASE_URL = window.location.hostname === 'localhost' 
    ? 'http://localhost:3004/api/embed'
    : 'https://hehostory.vercel.app/api/embed';
  
  // Fonction pour charger les donn√©es d'un widget
  const loadWidgetData = async (widgetId: string): Promise<Widget | null> => {
    try {
      console.log('üîç Chargement du widget:', widgetId);
      
      const response = await fetch(`${API_BASE_URL}/widget?id=${widgetId}`);
      const widget = await response.json();

      if (!response.ok) {
        console.error('‚ùå Erreur chargement widget:', widget.error);
        return null;
      }

      console.log('üì¶ Donn√©es brutes du widget:', widget);

      // Parse le format du widget
      let format: WidgetFormat;
      try {
        format = typeof widget.format === 'string' 
          ? JSON.parse(widget.format)
          : widget.format;
        console.log('üìê Format pars√©:', format);
      } catch (e) {
        console.error('‚ùå Erreur parsing format:', e);
        return null;
      }

      // Valeurs par d√©faut pour le format
      const defaultFormat: WidgetFormat = {
        type: 'bubble',
        size: 'M',
        alignment: 'center'
      };

      const processedWidget = {
        id: widget.id,
        format: {
          type: format.type || defaultFormat.type,
          size: format.size || defaultFormat.size,
          alignment: format.alignment || defaultFormat.alignment
        },
        story_ids: Array.isArray(widget.story_ids) ? widget.story_ids : [],
        settings: typeof widget.settings === 'string' 
          ? JSON.parse(widget.settings)
          : widget.settings || {}
      };

      console.log('‚úÖ Widget trait√©:', processedWidget);
      return processedWidget;

    } catch (error) {
      console.error('‚ùå Erreur inattendue widget:', error);
      return null;
    }
  };

  // Fonction pour charger les stories
  const loadStories = async (storyIds: string[]): Promise<Story[]> => {
    if (!storyIds.length) {
      console.log('‚ÑπÔ∏è Aucun story_id fourni');
      return [];
    }
    
    console.log('üîç Chargement des stories:', storyIds);
    
    try {
      const response = await fetch(`${API_BASE_URL}/stories?ids=${storyIds.join(',')}`);
      const stories = await response.json();

      if (!response.ok) {
        console.error('‚ùå Erreur chargement stories:', stories.error);
        return [];
      }

      console.log('üì¶ Stories brutes trouv√©es:', stories.map((s: DBStory) => s.id));

      const orderedStories = stories.map((story: DBStory) => ({
        id: story.id,
        content: story.content,
        thumbnail: story.thumbnail,
        profile_image: story.profile_image || undefined,
        profile_name: story.profile_name || undefined
      }));

      console.log('‚úÖ Stories trait√©es:', orderedStories.map((s: Story) => s.id));
      return orderedStories;

    } catch (error) {
      console.error('‚ùå Erreur inattendue stories:', error);
      return [];
    }
  };

  // Fonction d'initialisation du widget
  const initWidget = async (element: HTMLElement, widgetId: string) => {
    console.log('üöÄ Initialisation du widget:', widgetId);
    console.log('üìç Element DOM cible:', element);
    
    try {
      const widget = await loadWidgetData(widgetId);
      if (!widget) {
        console.error('‚ùå Widget non trouv√©:', widgetId);
        return;
      }

      console.log('üì± Chargement des stories pour le widget:', widget.story_ids);
      const stories = await loadStories(widget.story_ids);
      console.log('‚ú® Stories charg√©es:', stories.length);
      console.log('üìä D√©tails des stories:', stories.map(s => ({ id: s.id, thumbnail: s.thumbnail })));

      // Cr√©er un conteneur pour le viewer avec debug
      let viewerContainer = document.getElementById('hehostory-viewer-container');
      console.log('üîç Recherche du conteneur existant:', viewerContainer ? 'trouv√©' : 'non trouv√©');
      
      if (!viewerContainer) {
        viewerContainer = document.createElement('div');
        viewerContainer.id = 'hehostory-viewer-container';
        document.body.appendChild(viewerContainer);
        console.log('‚ú® Nouveau conteneur cr√©√© et ajout√© au DOM');
      }

      // Render le widget avec React
      console.log('üé® D√©but du rendu React du carousel');
      ReactDOM.render(
        React.createElement(StoryCarousel, {
          stories,
          variant: widget.format.type,
          size: widget.format.size,
          alignment: widget.format.alignment,
          onStorySelect: (story) => {
            console.log('üëÜ Story s√©lectionn√©e:', story.id);
            console.log('üìê Format du widget:', widget.format);
            console.log('üéØ Conteneur du viewer:', viewerContainer);
            
            // Utiliser createPortal via StoryViewer pour afficher la story
            if (viewerContainer) {
              console.log('üé≠ Montage du viewer dans le conteneur:', viewerContainer.id);
              ReactDOM.render(
                React.createElement(StoryViewer, {
                  stories,
                  selectedStoryId: story.id,
                  onClose: () => {
                    if (viewerContainer) {
                      console.log('üîö Fermeture du viewer');
                      console.log('üßπ Nettoyage du conteneur:', viewerContainer.id);
                      ReactDOM.unmountComponentAtNode(viewerContainer);
                      console.log('‚úÖ Viewer d√©mont√© avec succ√®s');
                    } else {
                      console.error('‚ùå Conteneur du viewer non trouv√© lors de la fermeture');
                    }
                  }
                }),
                viewerContainer
              );
              console.log('‚úÖ Viewer mont√© avec succ√®s');
            } else {
              console.error('‚ùå Conteneur du viewer non trouv√©');
            }
          }
        }),
        element
      );
      console.log('‚úÖ Carousel rendu avec succ√®s');
    } catch (error: any) {
      console.error('‚ùå Erreur initialisation widget:', error);
      console.error('üìë Stack trace:', error.stack);
    }
  };

  // Initialisation de tous les widgets sur la page
  const widgets = document.querySelectorAll('[data-hehostory-widget]');
  console.log('üîé Widgets trouv√©s:', widgets.length);
  
  widgets.forEach(element => {
    const widgetId = element.getAttribute('data-hehostory-widget');
    console.log('üìç Widget ID trouv√©:', widgetId);
    if (widgetId) {
      initWidget(element as HTMLElement, widgetId);
    }
  });
})(); 